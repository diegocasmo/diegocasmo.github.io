{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2016-01-28-better-performance-on-the-client/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Diego Castillo"}},"markdownRemark":{"id":"3cbab1e7-b7a8-5d96-a767-4b0a855b0819","excerpt":"Performance and responsiveness on client side applications are very important topics which usually don’t receive much attention until they are an obvious…","html":"<p>Performance and responsiveness on client side applications are very important topics which usually don’t receive much attention until they are an obvious problem. At <a href=\"http://www.ubiqua.me/\">Ubiqua</a>, as we began to increment the number of features our product offered, we started to experience the following problems:</p>\n<ul>\n<li>Application reloaded too often in mobile devices.</li>\n<li>Application took too long to reload.</li>\n<li>UI thread performed heavy computations which resulted in bad UX.</li>\n<li>Overall application performance was poor.</li>\n</ul>\n<p>In this blogpost, I’ll show some of the techniques we used to enhance the performance and responsiveness of our application.</p>\n<h3>Measure Then Act</h3>\n<p>The very first thing we have to make sure we do before attempting to fix anything, is to measure what we believe is causing the application to perform poorly. Chrome DevTools offer a variety of tools which facilitate this:</p>\n<ul>\n<li>\n<p><a href=\"https://developer.chrome.com/devtools/docs/cpu-profiling\">Collect JavaScript CPU Profile</a>: CPU profiles help to visualize where the execution time is spent in the JavaScript that is being run. Collecting JavaScript CPU profile was critical for us to replicate user actions we already knew were performing slow. We identified methods executed during those user actions which were taking too long and then optimized them. After these methods were optimized, we collected another CPU profile by executing the same previous user actions and we measured if the execution time had decreased in comparison with the first measurements. The console API method <code class=\"language-text\">console.profile([label])</code> can turn out to be helpful here as it allows you to measure user actions from specific places in the code and make comparisons.</p>\n</li>\n<li>\n<p><a href=\"https://developer.chrome.com/devtools/docs/heap-profiling\">Take Heap Snapshot</a>: A heap snapshot profile shows memory distribution among JavaScript objects and related DOM nodes.</p>\n</li>\n</ul>\n<p>A key concept to understand when taking heap snapshots is the difference between <code class=\"language-text\">shallow size</code> and <code class=\"language-text\">retained size</code> of a JavaScript object. Shallow size refers to the size of memory that is held by the object itself, while retained size is the size of memory that is freed once the object is garbage collected. When taking heap snapshots, we payed special attention to objects which had a large retained size and thus prevented other objects from being freed from memory. We made a list of these objects and proceeded to re-factor them to only initialize other objects/dependencies when it was strictly needed (if it was needed at all). After that, we took comparison heap snapshots to check if the in memory object count was reducing or incrementing.</p>\n<ul>\n<li><a href=\"https://developer.chrome.com/devtools/docs/timeline\">Timeline Analysis</a>: The Timeline panel records and analyzes all the activity in an application as it runs. Timeline analysis was convenient for discovering what was making our application take so long when reloading. We learned that is was garbage collection and then proceeded to take heap snapshots to further investigate the issue.</li>\n</ul>\n<h3>Freeing up the UI Thread</h3>\n<p>To battle against the UI thread being blocked by heavy computations we decided to use <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\">Web Workers</a>. A Web Worker provides an API to delegate work to a different thread such that the main UI thread is free to receive user interaction. An important observation to make when using Web Workers is that a new variable has to be added to the time taking to execute a script: <code class=\"language-text\">communication</code>. In addition to the time taken by the script to execute, we must add the time it takes for the application to send the message to the Web Worker, and the time it takes to the Web Worker to send the result back to the application. Because of this, when working with Web Workers always make sure to only pass and return from the Web Worker the information that is needed.</p>\n<h3>Faster Rendering</h3>\n<p>Modifying the DOM through JavaScript is expensive and should only be done when it is a must. We were able to make several performance improvements when the DOM had to be updated by doing the following:</p>\n<ul>\n<li>Use small view components: When data changes small parts of the DOM have to be re-rendered as opposed to re-rendering large parts of it.</li>\n<li>Map child views of a collection and then append to DOM instead of appending each child view individually.</li>\n<li><a href=\"http://stackoverflow.com/a/779785\">Using <code class=\"language-text\">setTimeout</code> of <code class=\"language-text\">0</code> to render non high priority content</a>: Give the browser a chance to finish doing some non-JavaScript things that have been waiting to finish before attempting to execute this new piece of JavaScript. In other words, it re-queues the new JavaScript at the end of the execution queue.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>In the past months we have learned a lot about improving client side application performance, and many of the techniques described above have now become implicit in our development workflow. Application performance and responsiveness should always be a high priority task in your team, as it directly relates with the main stakeholder of your application: the user.</p>","frontmatter":{"title":"Improving Application Performance and Responsiveness on the Client","date":"January 28, 2016","description":null}},"previous":{"fields":{"slug":"/2016-01-18-getting-started-with-acceptance-testing/"},"frontmatter":{"title":"Getting Started With Acceptance Testing"}},"next":{"fields":{"slug":"/2016-03-07-an-introduction-to-data-mining/"},"frontmatter":{"title":"An Introduction to Data Mining"}}},"pageContext":{"id":"3cbab1e7-b7a8-5d96-a767-4b0a855b0819","previousPostId":"ab1ed33e-7847-5f6e-96b7-e1579545078b","nextPostId":"93cc6a87-70aa-58d0-a3fa-8a9b54a5fdfb"}},
    "staticQueryHashes": ["650872877"]}