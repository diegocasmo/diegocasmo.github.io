{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2025-08-05-reducing-type-overhead-with-lazy-evaluation-in-typescript/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Diego Castillo"}},"markdownRemark":{"id":"1eaeed84-cb28-5846-be83-8d1d654cc540","excerpt":"When working on large TypeScript codebases, it’s easy to introduce performance issues through how types are written. One case we ran into involved building…","html":"<p>When working on large TypeScript codebases, it’s easy to introduce performance issues through how types are written. One case we ran into involved building helper types over all API routes, which caused the type checker to slow down significantly.</p>\n<p>The insight and solution presented here came from my teammate <a href=\"https://www.linkedin.com/in/jose-mussa/\">José Mussa</a>, who identified the root cause and proposed the fix that made a real difference in our day-to-day development.</p>\n<h2>The Problem</h2>\n<p>Suppose we define an API map like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ApiRoutes</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">'/users'</span><span class=\"token operator\">:</span> User<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">'/posts'</span><span class=\"token operator\">:</span> Post<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">'/comments'</span><span class=\"token operator\">:</span> Comment<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now we want to create a type that describes the shape of a <code class=\"language-text\">GET</code> response:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ApiGet</span> <span class=\"token operator\">=</span> ApiResponse<span class=\"token operator\">&lt;</span><span class=\"token keyword\">keyof</span> ApiRoutes<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// problematic</span></code></pre></div>\n<p>At a glance, this looks fine. But <code class=\"language-text\">keyof ApiRoutes</code> becomes <code class=\"language-text\">'/users' | '/posts' | '/comments'</code>, and TypeScript will attempt to resolve <code class=\"language-text\">ApiResponse</code> for every key in that union at once.</p>\n<p>With only a few paths, this isn’t a problem. But with hundreds of endpoints, this approach led to slow editor feedback and long type-checking times.</p>\n<h2>The Fix</h2>\n<p>Instead of evaluating all possible paths up front, we changed the type to compute responses only for the path being used:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">ApiGet<span class=\"token operator\">&lt;</span>Path <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> ApiRoutes<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> ApiResponse<span class=\"token operator\">&lt;</span>Path<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This change meant TypeScript would only resolve the types for the specific path we passed in. Since our <a href=\"https://diegocasmo.github.io/2022-12-19-api-using-axios-react-query/\">internal hooks</a> already received a path as a parameter, updating the generic definition was all it took to reduce the load.</p>\n<h2>What to Avoid</h2>\n<p>If you’re working with a large object and using <code class=\"language-text\">keyof</code> directly inside a type like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Something</span> <span class=\"token operator\">=</span> Wrapper<span class=\"token operator\">&lt;</span><span class=\"token keyword\">keyof</span> BigMap<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Consider refactoring it to a generic form:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Something<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> BigMap<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> Wrapper<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This avoids building massive unions ahead of time and keeps the compiler focused.</p>\n<h2>Summary</h2>\n<p>Evaluating wide unions too early can become expensive. Switching to lazy evaluation through generics is a simple way to keep TypeScript fast and predictable as the codebase grows.</p>\n<p>Have you run into similar slowdowns in your project? What other strategies have worked for you when dealing with deep or wide types? Curious to hear how others are approaching this.</p>","frontmatter":{"title":"Reducing Type Overhead with Lazy Evaluation in TypeScript","date":"August 05, 2025","description":null}},"previous":{"fields":{"slug":"/2024-10-07-simple-next.js-magic-link-jwt-authentication-with-prisma-postgresql-and-resend/"},"frontmatter":{"title":"Simple Next.js Magic Link JWT Authentication with Prisma, PostgreSQL, and Resend"}},"next":null},"pageContext":{"id":"1eaeed84-cb28-5846-be83-8d1d654cc540","previousPostId":"5b81c363-f23a-51c5-ac59-3e5ea43039e7","nextPostId":null}},
    "staticQueryHashes": ["650872877"]}